
---- ANTECEDENTES

La ingeniería inversa no es un concepto específico de la informática. Básicamente, es averiguar cómo funciona algo ya construido. En ingeniería, tienes conocimiento y lo aplicas para construir un producto, y en la ingeniería inversa, tienes el producto y lo que buscas es el conocimiento.

Aquí podemos ver un par de ejemplos de ingeniería inversa aplicada a productos militares. Esto es una máquina Enigma, usada en la época de la segunda guerra mundial por los alemanes para cifrar sus comunicaciones. La versión militar alemana era una versión mejorada, pero secreta. Al aplicar ingeniería inversa y reconstruirla los aliados, se pudieron interceptar mensajes importantes que resultaron decisivos en el transcurso de la guerra.

Esto es un misil aire-aire soviético, el K-13, una copia casi idéntica del AIM-9 estadounidense. La copia fue posible gracias a que un misil disparado contra un caza chino, en vez de explotar, se quedó atascado. El piloto consiguió aterrizar, se recuperó el misil, y los rusos convencieron a los chinos para que se lo dieran. El ingeniero jefe de la companía que lo examinó dijo que para ellos fue como un curso universitario en tecnología de construcción de misiles.

---- APLICACIONES EN INFORMÁTICA

Naturalmente, estamos en informática, así que vamos a introducir la ingeniería inversa en el campo de la informática, y concretamente su aplicación en el análisis de ejecutables.

¿Para qué se suele usar la ingeniería inversa en informática?

Por ejemplo, para cualquier modificación (ya sea para corregir o mejorar) de programas existentes sin código fuente. Especial mención a la ingeniería inversa sobre programas para permitir su interacción con otros, algo totalmente legal en Europa y Estados Unidos.

También se usa para analizar malware. Por alguna extraña razón a los programadores de malware se les suele olvidar liberar el código fuente de sus creaciones, por lo que para saber lo que hace un malware, hay que recurrir a la ingeniería inversa.

Otra aplicación típica es la búsqueda de vulnerabilidades en programas de código cerrado. Como curiosidad, los programadores de exploits suelen aplicar ingeniería inversa a los parches de productos que corrigen vulnerabilidades. Comparando la versión previa (vulnerable) con la versión corregida con un comparador de binarios, se puede ver la parte de código que varía. Se analiza entonces la vulnerabilidad corregida y se crea un exploit para ésta, que funcionará mientras las víctimas potenciales no actualicen.

Y finalmente, una aplicación controvertida de la ingeniería inversa, crackear programas. La definición en Wikipedia es "la modificación de programas para eliminar o desactivar características consideradas indeseables por la persona crackeando el programa". La característica indeseable suele ser una protección anticopia, mensajes que te recuerdan que no has registrado el programa, publicidad...

---- TIPOS DE ANÁLISIS

A la hora de analizar un ejecutable, tenemos dos opciones, analizarlo de forma estática o dinámica. Básicamente, en un análisis estático no se ejecuta el ejecutable, y en un análisis dinámico, sí. Además, cada tipo de análisis puede ser manual o automático.

En un análisis estático manual, abriríamos el ejecutable con un desensamblador y veríamos el listado de instrucciones. Si el ejecutable no modifica su propio código en tiempo de ejecución y no está ofuscado (código intencionalmente complicado de entender), dedicándole tiempo se puede llegar a conocer lo que hace el ejecutable en su totalidad. Un ejemplo de análisis estático automático es lo que hace un decompilador, que coge instrucciones en ensamblador e intenta recuperar el código fuente hasta cierto punto.

En un análisis dinámico manual, abriríamos el depurador, y mientras se ejecuta el programa, podríamos observar el listado de instrucciones que se están ejecutando, y modificar el flujo del programa al vuelo. En realidad, lo suyo es que un buen depurador contenga un buen desensamblador, pero en la práctica cada uno se especializa más en lo suyo. Un ejemplo de análisis dinámico automático es lo que hace una sandbox de análisis de malware, que ejecuta la muestra en un entorno controlado (generalmente una máquina virtual) y recopila información sobre la actividad del ejecutable en el sistema (comportamiento).
